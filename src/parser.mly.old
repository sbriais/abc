/* File parser.mly */
%{
  let fail s n =
    failwith ("Error after "
	      ^
	      s
(*
	      ^
	      " at position "
	      ^(string_of_int ((rhs_start n)))
*)
	     )
%}

%token <string> VAR
%token <string> IDENT
%token <int> INT
%token NU LAMBDA DOT OUTPUT TAU NIL COMMA
%token LBRACKET RBRACKET GT LESS
%token LPAREN RPAREN
%token PAR PLUS EQUAL
%token EOL
%token YES NO
%token AGENT EQ WEQ EXIT SHOW EQD WEQD PRINT RESET STEP LATEX HELP RATE MAXRATE LOAD PUSH POP IMPLICIT
%token INVALID
%start command             /* the entry point */
%start yes_no
%start number
%type <Commands.command> command
%type <bool> yes_no
%type <int> number
%%


command:
AGENT IDENT EQUAL agent EOL       { Agent_parse.helper#define $2;Commands.Def($2,List.fold_right (fun n a -> Agent.Abs(Agent.add_binder n a)) (Agent_parse.helper#get_context $2) $4) }
| AGENT IDENT LPAREN vars RPAREN EQUAL agent EOL { Agent_parse.helper#define $2;Commands.Def($2,List.fold_right (fun n a -> Agent.Abs(Agent.add_binder n a)) ((Agent_parse.helper#get_context $2)@$4) $7) } 
| EQ agent agent EOL              { Commands.Eqd([],$2,$3) }
| WEQ agent agent EOL             { Commands.Weqd([],$2,$3) }
| EQD LPAREN vars RPAREN agent agent EOL 
                                  { Commands.Eqd($3,$5,$6) }
| WEQD LPAREN vars RPAREN agent agent EOL 
                                  { Commands.Weqd($3,$5,$6) }
| EXIT EOL                        { Commands.Exit }
| RESET EOL                       { Commands.Reset }
| HELP EOL                        { Commands.Help }
| RATE INT EOL                    { Commands.Rate($2) }
| MAXRATE INT EOL                 { Commands.Maxrate($2) }
| SHOW agent EOL                  { Commands.Show($2) }
| PRINT agent EOL                 { Commands.Print($2) }
| LATEX agent EOL                 { Commands.Latex($2) }
| STEP agent EOL                  { Commands.Step($2) }
| LOAD VAR EOL                    { Commands.Load($2) }
| LOAD IDENT EOL                  { Commands.Load($2) }
| PUSH vars_space EOL             { Commands.Push($2) }
| POP EOL                         { Commands.Pop(1) }
| POP INT EOL                     { Commands.Pop($2) }
| IMPLICIT EOL                    { Commands.Implicit }

| AGENT error EOL                 { fail "AGENT" 2 }
| AGENT IDENT error EOL           { fail "AGENT IDENT" 3 }
| AGENT IDENT EQUAL error EOL     { fail "AGENT IDENT EQUAL" 4 }
| AGENT IDENT LPAREN error EOL    { fail "AGENT IDENT LPAREN" 4 }
| AGENT IDENT LPAREN vars error EOL { fail "AGENT IDENT LPAREN vars" 5 }
| AGENT IDENT LPAREN vars RPAREN error EOL { fail "AGENT IDENT LPAREN vars RPAREN" 4 }
| AGENT IDENT LPAREN vars RPAREN EQUAL error EOL { fail "AGENT IDENT LPAREN vars RPAREN EQUAL" 7 }
| EQ error EOL                    { fail "EQ" 2 }
| EQ agent error EOL              { fail "EQ agent" 3 }
| WEQ error EOL                   { fail "WEQ" 2 }
| WEQ agent error EOL             { fail "WEQ agent" 3 }
| SHOW error EOL                  { fail "SHOW" 2 }
| PRINT error EOL                 { fail "PRINT" 2 }
| LATEX error EOL                 { fail "LATEX" 2 }
| STEP error EOL                  { fail "STEP" 2 }
| EQD error EOL                   { fail "EQD" 2 }
| EQD LPAREN error EOL            { fail "EQD LPAREN" 3 }
| EQD LPAREN vars error EOL       { fail "EQD LPAREN vars" 4 }
| EQD LPAREN vars RPAREN error EOL { fail "EQD LPAREN vars RPAREN" 5 }
| EQD LPAREN vars RPAREN agent error EOL { fail "EQD LPAREN vars RPAREN agent" 6 }
| WEQD error EOL                  { fail "WEQD" 2 }
| WEQD LPAREN error EOL           { fail "WEQD LPAREN" 3 }
| WEQD LPAREN vars error EOL      { fail "WEQD LPAREN vars" 4 }
| WEQD LPAREN vars RPAREN error EOL { fail "WEQD LPAREN vars RPAREN" 5 }
| WEQD LPAREN vars RPAREN agent error EOL { fail "WEQD LPAREN vars RPAREN agent" 6 }
| error EOL                       { fail "Invalid command." 1 }
;

prefix:
  TAU                          { Agent.Tau,[] }
| VAR params                   { Agent.Input(Agent_parse.helper#get $1),$2 }
| OUTPUT VAR oparams           { Agent.Output(Agent_parse.helper#get $2),$3 }
;

vars:
  VAR                          { [Agent_parse.helper#get $1] }
| vars COMMA VAR               { $1@[Agent_parse.helper#get $3] }
;

vars_space:
  VAR                          { [Agent_parse.helper#get $1] }
| vars_space VAR               { $1@[Agent_parse.helper#get $2] }
;

params:
/* epsilon */                  { [] }
| LPAREN vars RPAREN           { $2 }
;

oparams:
/* epsilon */                  { [] }
| LESS vars GT                 { $2 }
;

agent:
  agent_facteur                { $1 }
| agent_facteur PLUS agent     { Agent.Sum(Agent.AgentMultiset.add $1 1 (Agent.AgentMultiset.singleton $3)) }
;

agent_facteur:
  agent_garde                  { $1 }
| agent_garde PAR agent_facteur { Agent.Parallel(Agent.AgentMultiset.add $1 1 (Agent.AgentMultiset.singleton $3)) }
;

agent_garde:
  NIL                          { Agent.Nil }
| INT                          { if $1 = 0 then Agent.Nil else raise Parse_error }
| prefix DOT agent_garde       { let (a,vs) = $1 in
				   match a with
				       Agent.Tau -> Agent.Prefix(a,$3)
				     | Agent.Input(_) -> Agent.Prefix(a,List.fold_right (fun n a -> Agent.Abs(Agent.add_binder n a)) vs $3)
				     | Agent.Output(_) -> Agent.Prefix(a,List.fold_right (fun n a -> Agent.Conc(n,a)) vs $3) }
| LBRACKET vars RBRACKET agent_garde { List.fold_right (fun n a -> Agent.Conc(n,a)) $2 $4 }
| LBRACKET VAR EQUAL VAR RBRACKET agent_garde 
                               { Agent.Match(Agent_parse.helper#get $2,Agent_parse.helper#get $4,$6) }
| LPAREN LAMBDA vars RPAREN agent_garde
			       { List.fold_right (fun n a -> Agent.Abs(Agent.add_binder n a)) $3 $5 }
| LPAREN NU vars RPAREN agent_garde  { List.fold_right (fun n a -> Agent.Nu(Agent.add_binder n a)) $3 $5 }  
| LPAREN agent RPAREN          { $2 }
| IDENT params                 { List.fold_left (fun a v -> Agent.Apply(a,v)) (Agent.AgentRef($1)) ((Agent_parse.helper#get_context $1)@$2) }
| agent_garde VAR              { Agent.Apply($1,Agent_parse.helper#get $2) }
;

yes_no:
YES EOL                        { true }
| NO EOL                       { false}
| error EOL                    { fail "Answer with yes or no." 1 }
;

number:
INT EOL                        { $1 }
| error EOL                    { fail "Answer with a number." 1 }
;
