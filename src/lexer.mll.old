(* File lexer.mll *)
{
  open Parser        (* The type token is defined in parser.mli *)
  exception Eof

  let keyword_table = Hashtbl.create 53
  let _ =
    List.iter (fun (kwd, tok) -> Hashtbl.add keyword_table kwd tok)
      [ "agent", AGENT;
	"t", TAU;
	"eq", EQ;
	"weq", WEQ;
	"exit",EXIT;
	"show",SHOW;
	"eqd", EQD;
	"weqd", WEQD;
	"reset", RESET;
	"print", PRINT;
	"step", STEP;
	"latex",LATEX;
	"help", HELP;
	"value",RATE;
	"scale",MAXRATE;
	"load",LOAD;
	"push",PUSH;
	"pop",POP;
	"implicit",IMPLICIT
      ]

  let (init,enter,exit,is_toplevel) = 
    let counter = ref 0 in
    let init () = counter := 0
    and enter () = incr counter
    and exit () = decr counter
    and is_toplevel () = (!counter) = 0
    in (init,enter,exit,is_toplevel)
}

rule command = parse
    [' ' '\t']     { command lexbuf }     (* skip blanks *)
  | '\\'[' ''\t']*'\n'         { command lexbuf }
  | "(*"           { init();enter();comments lexbuf }
  | '\n'           { EOL }
  | ['a'-'z']['/''_''A'-'Z''a'-'z''0'-'9']*  { let s = Lexing.lexeme lexbuf in
						 (try
						    Hashtbl.find keyword_table s
						  with
						      Not_found -> VAR(s))
					     }
  | ['A'-'Z']['_''A'-'Z''a'-'z''0'-'9']*  { IDENT(Lexing.lexeme lexbuf) }
  | ['0'-'9']+     { INT(int_of_string(Lexing.lexeme lexbuf)) }
  | '^'            { NU }
  | '\\'           { LAMBDA }
  | '.'            { DOT }
  | '\''           { OUTPUT }
  | '|'            { PAR }
  | '+'            { PLUS }
  | '='            { EQUAL }
  | '['            { LBRACKET }
  | ']'            { RBRACKET }
  | '('            { LPAREN }
  | ')'            { RPAREN }
  | ','            { COMMA }
  | '<'            { LESS }
  | '>'            { GT }
  | '0'            { NIL }
  | eof            { raise Eof }
  | _              { INVALID }
and comments = parse
    "(*"           { enter();comments lexbuf }
  | "*)"           { exit();if (is_toplevel ()) then (command lexbuf) else (comments lexbuf) }
  | _              { comments lexbuf }
and yes_no = parse
    'y'
  | "yes"  
  | "Yes"         { YES }
  | 'n'
  | "no"           
  | "No"          { NO }
  | '\n'          { EOL }
  | [' ' '\t']    { yes_no lexbuf }
  | eof           { raise Eof }
  | _             { INVALID }
and number = parse
  | ['0'-'9']+    { INT(int_of_string (Lexing.lexeme lexbuf)) }
  | '\n'          { EOL }
  | [' ' '\t']    { number lexbuf }
  | eof           { raise Eof }
  | _             { INVALID }
