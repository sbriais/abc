(* we played a bit with an "efficient" representation of integer *)
(* the data type is (ocaml style): *)
(* type integer = Z | SD of integer | D of integer *)
(* it is interpreted as: *)
(* [Z] = 0 *)
(* [SD(n)] = 2*[n]+1 *)
(* [D(n)] = 2*[n] *)
(* These integers are not persistent *)

(* we first define three "constructors" *)

push l
agent Z = l(z,sd,d).'z
agent SD(n) = l(z,sd,d).'sd<n>
agent D(n) = l(z,sd,d).'d<n>
pop

(* Move moves the integer at location l to location m *)
agent Move(l,m) = \
	(^caseZ,caseSD,caseD) \
		(  'l<caseZ,caseSD,caseD> \
		 | (  caseZ.Z(m) \
		    + caseSD(lp).SD(m,lp) \
		    + caseD(lp).D(m,lp)))

(* Copy copys the integer at location l to location m and n *)
agent Copy(l,m,n) = \
	(^caseZ,caseSD,caseD) \
		(  'l<caseZ,caseSD,caseD> \
		 | (  caseZ.(Z(m) | Z(n)) \
		    + caseSD(lp).(^mp,np)(SD(m,mp) | SD(n,np) | Copy(lp,mp,np)) \
		    + caseD(lp).(^mp,np)(D(m,mp) | D(n,np) | Copy(lp,mp,np))))

agent Zero(l) = Z(l)
agent One(l) = (^k)(SD(l,k) | Zero(k))

(* Succ computes the successor of the integer located at l and put it at m *)
agent Succ(l,m) = \
	(^caseZ,caseSD,caseD) \
	       (  'l<caseZ,caseSD,caseD> \
                | (  caseZ.One(m) \
                   + caseSD(lp).(^mp)(D(m,mp) | Succ(lp,mp)) \
                   + caseD(lp).SD(m,lp)))

(* Add adds the two integers located at l and m and put the result at n *)
agent Add(l,m,n) = \
	(^caseZ,caseSD,caseD) \
	       (  'l<caseZ,caseSD,caseD> \
                | (  caseZ.Move(m,n) \
                   + caseSD(lp).(  'm<caseZ,caseSD,caseD> \
                                 | (  caseZ.SD(n,lp) \
                                    + caseSD(mp).(^np)(D(n,np) | (^lpmp)((Add(lp,mp,lpmp) | Succ(lpmp,np)))) \
                                    + caseD(mp).(^np)(SD(n,np) | Add(lp,mp,np)))) \
                   + caseD(lp).(   'm<caseZ,caseSD,caseD> \
                                |  (  caseZ.D(n,lp) \
                                    + caseSD(mp).(^np)(SD(n,np) | Add(lp,mp,np)) \
                                    + caseD(mp).(^np)(D(n,np) | Add(lp,mp,np)))))) 

agent Two(l) = (^k)(D(l,k) | One(k))
agent Three(l) = (^k)(SD(l,k) | One(k))
agent Four(l) = (^k)(D(l,k) | Two(k))
agent Five(l) = (^k)(SD(l,k) | Two(k))
agent Six(l) = (^k)(D(l,k) | Three(k))

(* Mult multiplies the two integers located at l and m and put the result at n *)
agent Mult(l,m,n) = \
	(^caseZ,caseSD,caseD) \
	       (  'l<caseZ,caseSD,caseD> \
                | (  caseZ.Z(n) \
                   + caseSD(lp).((^m1,m2)(Copy(m,m1,m2) | (^lpm)(Mult(lp,m1,lpm) | Add(lpm,m2,n)))) \
                   + caseD(lp).(^np)(D(n,np) | Mult(lp,m,np))))

